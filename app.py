# Trabalho Final
# Valor (5.0)



# Aplicação Web com Análise de Dados e Machine Learning

# Desenvolver uma aplicação web utilizando Python, que
# permita ao usuário fazer o upload de arquivos de dados no
# formato .csv e realizar análises visuais e predições com
# machine learning. O objetivo é oferecer insights interativos e
# predições personalizadas, com base em variáveis presentes
# nos dados, possibilitando diferentes tipos de visualizações e
# uso de classificadores configuráveis pelo usuário.



# TEMA
# O tema do conjunto de dados e os objetivos de análise com recursos de aprendizado de
# máquina ficarão a encargo da equipe e devem ser apresentados ao professor antes de
# iniciar as atividades de desenvolvimento, para evitar temas duplicados na turma.
# Então, lembre-se de dizer seu tema durante a aula ou, caso não consiga estar em sala,
# via mensagem no blackboard. Assim, caso haja temas iguais a ordem de horário será
# respeitada com prioridade aos grupos que estavam em sala.



# Funcionalidades
# 1. Upload e Flexibilidade dos Dados
# 2. Análise de Dados e Visualização
# 3. Machine Learning com Personalização de Modelos
# 4. Treinamento Dinâmico do Modelo



# Upload e Flexibilidade dos Dados
# ● A aplicação deverá permitir o upload de um arquivo .csv, que contenha dados
# estruturados em colunas consistentes. A aplicação deve ser capaz de gerar gráficos e
# análises automaticamente, considerando que o usuário poderá enviar diferentes bases
# com as mesmas colunas. A flexibilidade dos dados é essencial para permitir a análise de
# dados variados, como de imóveis de cidades diferentes, jogos novos, ou atualização de
# dados cursos online.



# Análise de Dados e Visualização
# A aplicação deve gerar gráficos de análise com as variáveis do dataset, usando tanto gráficos
# básicos (como gráficos de barras e pizza) quanto gráficos mais avançados e interativos, como
# mapas para visualização de dados geográficos. Por exemplo:
# ● Imóveis: Visualizar a distribuição de preços por bairro, a localização dos imóveis no
# mapa, e a relação entre o preço e características como tamanho, número de quartos e
# ano de construção.
# ● Jogos: Analisar popularidade por país, tipos de jogos mais jogados por região,
# distribuição de avaliações por gênero e gênero predominante em cada país.
# ● Cursos Online: Visualizar a popularidade por temas de cursos em cada país, preços
# médios por idioma e país, e a distribuição de alunos por área de estudo ou tipo de
# curso.



# Machine Learning
# A aplicação deve permitir ao usuário realizar predições com base em atributos relevantes,
# como por exemplo: estimar o preço de uma nova casa com base em combinações como
# bairro, metragem (m²), número de quartos, ano de construção, número de banheiros e
# proximidade de serviços essenciais (escolas, transporte público). Outros exemplos no
# próximo slide.
# ● Escolha e Configuração de Classificadores: O usuário deverá poder escolher entre
# diferentes classificadores/preditores e ajustar seus parâmetros (como profundidade
# em árvores de decisão ou número de vizinhos em KNN). Essa funcionalidade permite
# que o usuário teste múltiplos modelos e visualize como diferentes configurações
# influenciam as previsões.



# Exemplos
# ● Jogos: Prever a probabilidade de sucesso de um jogo considerando atributos como
# preço, nicho, gênero, número de jogadores simultâneos, faixa etária do público, e
# presença de recursos multiplayer. Também é possível estimar o preço ideal para um
# jogo com base em avaliações, gênero, nicho e média de avaliações dos jogos no mesmo
# gênero.
# ● Cursos Online: Prever o preço ideal de um curso com base em país, idioma, tema,
# duração do curso, e nível de dificuldade. Outra predição pode envolver estimar o
# número de alunos que o curso atrairá com base em variáveis como tipo de curso,
# linguagem, nível de engajamento esperado, e popularidade do tema em determinada
# região.



# Treinamento Dinâmico do Modelo
# ● Como a base de dados pode ser alterada com frequência, a aplicação deve incluir
# uma funcionalidade para re-treinar o modelo sempre que novos dados forem
# inseridos. Essa opção deve estar disponível para permitir ao usuário treinar o
# modelo conforme necessário para garantir predições atualizadas.
# Exemplo: cidades diferentes.



# Critérios de Avaliação
# 1. Qualidade Técnica da Implementação (0,5 ponto)
# 2. Análise de Dados (1,25 pontos)
# 3. Machine Learning (1,25 pontos)
# 4. Documentação (0,5 ponto)
# 5. Apresentação Final / Defesa de Código (1,5 ponto)



# Critérios de Avaliação
# Qualidade Técnica da Implementação (0,5 ponto)
# ● Uso de Ferramentas: Implementação correta de bibliotecas (ex.: pandas, matplotlib/seaborn, scikit-learn).
# ● Código Limpo: O código é legível, bem comentado e segue boas práticas de programação.
# ● Estrutura do Projeto: Organização lógica e modular do código e dos arquivos.
# ● Divisão de Tarefas: As responsabilidades foram claramente distribuídas entre os membros da equipe.
# Análise de Dados (1,25 pontos)
# ● Manipulação de Dados: Uso adequado do pandas para manipulação e limpeza dos dados.
# ● Visualização: Criação de gráficos informativos e bem apresentados, utilizando matplotlib, seaborn, ou
# gráficos interativos para melhorar a experiência do usuário.



# Critérios de Avaliação
# Machine Learning (1,25 pontos)
# ● Modelagem e Predição: Aplicação de técnicas de machine learning com scikit-learn, incluindo a seleção
# de modelos adequados ao problema.
# ● Configuração de Modelos: Implementação de opções de escolha de modelos e ajuste de parâmetros.
# ● Treinamento Dinâmico: Funcionalidade para re-treinar o modelo com novos dados.
# Documentação (0,5 ponto)
# ● README e Documentação: Disponibilização de um README detalhado e documentação explicativa para
# facilitar a compreensão e uso do código.



# Critérios de Avaliação
# Defesa de Código (1,5 ponto)
# ● Explicação Individual: Cada aluno deverá apresentar partes específicas do código, explicando sua
# funcionalidade, escolhas de implementação, e mostrando seu entendimento.
# ● Demonstração Prática: Demonstração prática das principais funcionalidades da aplicação durante a
# apresentação.
# ● Respostas a Perguntas: Cada membro deve estar preparado para responder perguntas técnicas sobre o
# código e as decisões tomadas no projeto.



# Como entregar?
# Criar uma conta e um repositório no GitHub.
# Este repositório deve conter todo os arquivos necessários para rodar o projeto.
# Enviar link do repositório na entrega do Blackboard. E mesmo com a entrega do blackboard se
# encerrando dia delimitado, não podem conter commits realizados após a data de entrega.
# Tamanho do grupo: 3 pessoas.
# Data de Entrega: Aulas da semana do dia 25/11 a 29/11


# exemplo de csv
# year_of_reference,month_of_reference,fipe_code,authentication,brand,model,fuel,gear,engine_size,year_model,avg_price_brl,age_years
# 2022,January,038001-6,vwmrywl5qs,Acura,NSX 3.0,Gasoline,manual,3.0,1995,43779.0,28
# 2022,January,038001-6,t9mt723qhz,Acura,NSX 3.0,Gasoline,manual,3.0,1994,42244.0,29
# 2022,January,038001-6,rtm9gj7zk8,Acura,NSX 3.0,Gasoline,manual,3.0,1991,35678.0,32
# 2022,January,038002-4,nlf2w6k7vd,Acura,Legend 3.2/3.5,Gasoline,manual,3.2,1998,27132.0,25
# 2022,January,038002-4,mcyp7ypwtc,Acura,Legend 3.2/3.5,Gasoline,manual,3.2,1997,23934.0,26
# 2022,January,038002-4,lxckds9y6h,Acura,Legend 3.2/3.5,Gasoline,manual,3.2,1996,22690.0,27


# pip install scikit-learn
# pip install sklearn
# pip install seaborn
# pip install pandas
# pip install matplotlib
# pip install joblib


from flask import Flask, render_template, request, redirect, url_for
import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
import joblib

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['ALLOWED_EXTENSIONS'] = {'csv'}

# Função para verificar se a extensão é permitida
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

# Rota para página inicial e upload do CSV
@app.route("/", methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files.get('file')
        if file and allowed_file(file.filename):
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(filepath)
            return redirect(url_for('visualize_data', filename=file.filename))
    return render_template("index.html")

# Rota para visualização dos dados e análises
@app.route("/visualize/<filename>")
def visualize_data(filename):
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    df = pd.read_csv(filepath)
    df_html = df.head().to_html(classes='table table-striped')
    return render_template("visualize.html", data=df_html, filename=filename)

# Rota para exibir gráficos
@app.route("/plot/<filename>")
def plot_data(filename):
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    df = pd.read_csv(filepath)
    
    # Gerar gráfico de exemplo
    plt.figure(figsize=(10, 6))
    sns.histplot(df['avg_price_brl'], bins=30, kde=True)
    plt.title("Distribuição de Preços Médios de Carros")
    plt.xlabel("Preço Médio (BRL)")
    plt.ylabel("Frequência")
    plot_path = os.path.join("static", "plot.png")
    plt.savefig(plot_path)
    return render_template("visualize.html", plot_path=plot_path, filename=filename)

# Rota para configurar e treinar o modelo
@app.route("/train/<filename>", methods=['GET', 'POST'])
def train_model(filename):
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    df = pd.read_csv(filepath)
    
    if request.method == 'POST':
        target = request.form['target']
        features = request.form.getlist('features')
        
        X = df[features]
        y = df[target]
        
        # Dividir dados
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Escolha de modelo
        model_choice = request.form['model']
        if model_choice == 'linear_regression':
            model = LinearRegression()
        elif model_choice == 'random_forest':
            model = RandomForestRegressor()
        
        model.fit(X_train, y_train)
        score = model.score(X_test, y_test)
        
        # Salvar o modelo
        model_path = os.path.join("models", f"{model_choice}.joblib")
        joblib.dump(model, model_path)
        
        return render_template("train_model.html", score=score, filename=filename)
    
    return render_template("train_model.html", columns=df.columns, filename=filename)

# Rota para fazer predições
@app.route("/predict/<filename>", methods=['GET', 'POST'])
def make_prediction(filename):
    model_path = os.path.join("models", "random_forest.joblib")  # exemplo de modelo carregado
    model = joblib.load(model_path)
    prediction = None

    if request.method == 'POST':
        features = [float(request.form.get(f'feature_{i}')) for i in range(len(request.form))]
        prediction = model.predict([features])[0]
    
    return render_template("predictions.html", prediction=prediction, filename=filename)

if __name__ == "__main__":
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    os.makedirs('models', exist_ok=True)
    app.run(debug=True)
